/*
AUTHOR: Avinash Srinivasan
Code File: hidingNoNullImg.c
This program hides a filesystem ".dmg" within the
slack space of files specified with a coverfile list.

The program takes as input the mapFile (.txt) the
null-free .dmg file generated by 'strippingNullBytes.c'
along with a coverfile list(.txt file) that has the
full-path of files that can be used as cover files
along with the available slack space for each potential
coverfile.
*/

// below macro def is necessary for asprintf
// has to appear before #include<stdio.h>
#ifndef _GNU_SOURCE
#define _GNU_SOURCE 1
#endif

#include "slackFS.h"

int main(int argc, char const *argv[]) {
    char fixedPATH[] = "../../";
    // char bmapPATH [] = " | sudo /home/osboxes/bmap/bmap --mode putslack ";
    char bmapPATH[] = " | sudo ../../bmap/bmap --mode putslack ";
    char srcFullPATH[128] = {0};
    char srcIMG[] = "imageFiles/myimg_noNull.img";
    strncpy(srcFullPATH, fixedPATH, strlen(fixedPATH));
    strcat(srcFullPATH, srcIMG);

    char mapPath[128] = {0};
    char mapFile[] = "textFiles/usrCoverFileList.txt";
    strncpy(mapPath, fixedPATH, strlen(fixedPATH));
    strcat(mapPath, mapFile);

    int sysCallRet;
    FILE *fp_mapFile, *fp_srcIMG;

    struct stat st;
    stat(srcFullPATH, &st);
    int statFileSize = st.st_size;

    fp_mapFile = fopen(mapPath, "r");
    printf("%s\n", mapPath);
    if (fp_mapFile == NULL) {
        perror("Message from perror: fopen (mapPath)");
        fclose(fp_mapFile);
        exit(EXIT_FAILURE);
    }

    printf("%s\n", srcFullPATH);
    fp_srcIMG = fopen(srcFullPATH, "rb");
    if (fp_srcIMG == NULL) {
        perror("Message from perror: fopen (srcIMG)");
        fclose(fp_srcIMG);
        exit(EXIT_FAILURE);
    }

    int coverFileCounter = 0, bytesWritten = 0, bytesRemaining = statFileSize;

    while (!feof(fp_mapFile) && !feof(fp_srcIMG)) {
        coverFileCounter++;

        puts("yeet");
        char finalCMD[1024] = {0}, coverFileName[128] = {0};
        int availableSlack = 0;

        char fixedCMDL[128] = "dd iflag=skip_bytes count=1 if=";

        char leftCMD[256] = {0};
        strncpy(leftCMD, fixedCMDL, strlen(fixedCMDL));
        strcat(leftCMD, srcFullPATH);
        strcat(leftCMD, " bs=");

        char fixedCMDR[128] = "\0";
        strncpy(fixedCMDR, bmapPATH, strlen(bmapPATH));
        char rightCMD[256] = {0};
        strncpy(rightCMD, fixedCMDR, strlen(fixedCMDR));
        printf("Rightcmd --> %s\n", fixedCMDR);

        fscanf(fp_mapFile, "%s", coverFileName);

        struct stat st1;
        printf("Cover File name: %s\n", coverFileName);
        if (stat(coverFileName, &st1) == -1) {
            if (S_ISREG(st1.st_mode) != 0) {
                printf("Error message inside: %s\n", strerror(errno));
                printf("Check for S_ISREG failed for %s. Skipping this file.\n", coverFileName);
                coverFileCounter--;
                continue;
            }
            printf("Error message outside: %s\n", strerror(errno));
        }
        strcat(rightCMD, coverFileName);
        fscanf(fp_mapFile, "%i", &availableSlack);

        char *skipSize;
        char *dd_BlockSize;

        if (bytesRemaining <= availableSlack) {
            asprintf(&dd_BlockSize, "%i", bytesRemaining);
            asprintf(&skipSize, "%i", bytesWritten);
            bytesWritten = bytesWritten + bytesRemaining;
            bytesRemaining = 0;
        }

        else {
            asprintf(&dd_BlockSize, "%i", availableSlack);
            asprintf(&skipSize, "%i", bytesWritten);
            bytesWritten = bytesWritten + availableSlack;
            bytesRemaining = bytesRemaining - availableSlack;
            if (bytesRemaining <= 0) {
                printf("Something went wrong. bytesRemaining = %i\n", bytesRemaining);
                exit(EXIT_FAILURE);
            }
        }

        strcat(leftCMD, dd_BlockSize);
        strcat(leftCMD, " skip=");
        strcat(leftCMD, skipSize);

        strcpy(finalCMD, leftCMD);
        strcat(finalCMD, rightCMD);
        printf("%s\n", finalCMD);
        sysCallRet = system(finalCMD);
        if (sysCallRet == -1 && WIFEXITED(sysCallRet)) {
            printf("Terminated with status %d\n", WEXITSTATUS(sysCallRet));
        }

        strncpy(leftCMD, "\0", 256);
        strncpy(rightCMD, "\0", 256);
        strncpy(finalCMD, "0", 1024);

        // printf("bytesWritten = %i\t bytesRemaining = %i\t
        // totalBytesCheck=%i\n\n\n", bytesWritten, bytesRemaining,
        // (bytesWritten+bytesRemaining)); printf("coverFileCounter = %d\n",
        // coverFileCounter);
    }

    fclose(fp_mapFile);
    fclose(fp_srcIMG);

    return 0;
}
