\documentclass[letterpaper]{article}
\usepackage{ifpdf}
\usepackage{linuxdoc-sgml}
\usepackage{qwertz}
\usepackage{url}
%%\usepackage[@CHARSET@]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[colorlinks=true,urlcolor=blue,linkcolor=blue,breaklinks=true]{hyperref}
\ifpdf\pdfcompresslevel=9\fi
\usepackage[english]{babel}
\usepackage{epsfig}
\usepackage{null}
\def\addbibtoc{
\addcontentsline{toc}{section}{\numberline{\mbox{}}\relax\bibname}
}%end-preamble
\setcounter{page}{1}
\title{File System Block-Mapping under Linux}
\author{Daniel Ridge, {\ttfamily \ifpdf
\href{mailto:newt@scyld.com}{newt@scyld.com}%
\else
\onlynameurl{newt@scyld.com}%
\fi{}
};}
\date{v1.0.17, 16 March 2000}
\abstract{The Linux kernel includes a powerful, filesystem independant mechanism for
mapping logical files onto the sectors they occupy on disk. While this
interface is nominally available to allow the kernel to efficiently retrieve
disk pages for open files or running programs, an obscure user-space interface
does exist.
This is an interface which can be handily subverted (with {\ttfamily bmap} and
freinds) to perform a variety of functions interesting to the computer
forensics community, the computer security community, and the high-performance
computing community.}


\begin{document}
\maketitle

\section{Downloading}

bmap is publicly available at the following location
\begin{itemize}
\item Web page: \ifpdf
\href{http://www.scyld.com/software/bmap.html}{http://www.scyld.com/software/bmap.html}%
\else
\onlynameurl{http://www.scyld.com/software/bmap.html}%
\fi{}
\item Source: \ifpdf
\href{ftp://ftp.scyld.com/pub/bmap/bmap-1.0.17.tar.gz}{ftp://ftp.scyld.com/pub/bmap/bmap-1.0.17.tar.gz}%
\else
\onlynameurl{ftp://ftp.scyld.com/pub/bmap/bmap-1.0.17.tar.gz}%
\fi{}
\end{itemize}





\subsection{Redistribution}

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.




\section{Usage}

The bmap package consists of 2 tools and a development library.
The standalone tools {\ttfamily bmap} and {\ttfamily slacker} are provided
as both useful standalone utilities and reference implementations of
{\ttfamily libbmap} applications.




\subsection{Building bmap }

{\ttfamily make} and {\ttfamily make install} should take care of it.

At this time, we have only worked out a bmap implementation on Linux.

These tools will install under {\ttfamily /usr/local} by default.




\subsection{Invoking the tools}


\subsubsection{{\ttfamily bmap} invocation}

{\ttfamily bmap [$<$OPTIONS$>$] [$<$target-filename$>$]}

Where {\bfseries OPTIONS} may include any of:
\begin{description}
\item[--doc VALUE] \mbox{}

where VALUE is one of:
\begin{description}
\item[version] \mbox{}

display version and exit

\item[help] \mbox{}

display options and exit

\item[man] \mbox{}

generate man page and exit

\item[sgml] \mbox{}

generate SGML invocation info

\end{description}


\item[--mode VALUE] \mbox{}

where VALUE is one of:
\begin{description}
\item[map] \mbox{}

list sector numbers

\item[carve] \mbox{}

extract a copy from the raw device

\item[slack] \mbox{}

display data in slack space

\item[putslack] \mbox{}

place data into slack

\item[wipeslack] \mbox{}

wipe slack

\item[checkslack] \mbox{}

test for slack (returns 0 if file has slack)

\item[slackbytes] \mbox{}

print number of slack bytes available

\item[wipe] \mbox{}

wipe the file from the raw device

\item[frag] \mbox{}

display fragmentation information for the file

\item[checkfrag] \mbox{}

test for fragmentation (returns 0 if file is fragmented)

\end{description}


\item[--outfile $<$filename$>$] \mbox{}

write output to ...

\item[--label] \mbox{}

useless bogus option

\item[--name] \mbox{}

useless bogus option

\item[--verbose] \mbox{}

be verbose

\item[--log-thresh $<$none $|$ fatal $|$ error $|$ info $|$ branch $|$ progress $|$ entryexit$>$] \mbox{}

logging threshold ...

\item[--target $<$filename$>$] \mbox{}

operate on ...

\end{description}







\subsubsection{{\ttfamily slacker} invocation}

{\ttfamily slacker [$<$OPTIONS$>$] [$<$path-filename$>$]}

Where {\bfseries OPTIONS} may include any of:
\begin{description}
\item[--doc VALUE] \mbox{}

where VALUE is one of:
\begin{description}
\item[version] \mbox{}

display version and exit

\item[help] \mbox{}

display options and exit

\item[man] \mbox{}

display man and exit

\item[sgml] \mbox{}

generate SGML invokation info

\end{description}


\item[--mode VALUE] \mbox{}

where VALUE is one of:
\begin{description}
\item[capacity] \mbox{}

measure slack capacity of path

\item[fill] \mbox{}

fill slack space with user data

\item[frob] \mbox{}

fill slack space with random data

\item[pour] \mbox{}

write out the contents of slack space

\item[wipe] \mbox{}

clear the contents of slack space

\end{description}


\item[--outfile $<$filename$>$] \mbox{}

write output to ...

\item[--verbose] \mbox{}

be verbose

\item[--log-thresh $<$none $|$ fatal $|$ error $|$ info $|$ branch $|$ progress $|$ entryexit$>$] \mbox{}

logging threshold ...

\item[--path $<$filename$>$] \mbox{}

operate on ...

\item[--recursive] \mbox{}

descend into subdirectories

\end{description}







\subsection{Limitations}

The bmap works against filesystems mounted on block devices.
You will not to be able to operate against filesystems mounted
via Samba, NFS, or any other network filesystem.

If you simply cannot use bmap on the machine storing the block
device or block device image, you can try the linux network block driver
to export the block device to the machine from which you wish to bmap. Also,
Scyld's userfs user-level filesystem code includes a sample application,
bush, which is linked against bmap.




\subsection{Technical Description / Implementation}






\subsubsection{VFS -- Linux 'Virtual Filesystem Switch'}

These notes are based on Linux 2.2.5 but should be widely portable
to other versions of the Linux kernel.

compiled with
\begin{verbatim}
#include <linux/fs.h>
\end{verbatim}


lives at 
\begin{verbatim}
((struct inode_operations *)foo)->bmap
\end{verbatim}


and is prototyped as 
\begin{verbatim}
int foo_bmap(struct inode *inode,int block);
\end{verbatim}





\subsubsection{FIBMAP -- userspace interface via ioctl}

\begin{verbatim}
#include <sys/ioctl.h>
#include <linux/fs.h>

retval=ioctl(fd,FIBMAP,&block_pos);
\end{verbatim}




Where {\ttfamily block\_pos} passes the index of the block you wish to
map and returns the index of that block with respect to the underlying
block device. It is important to understand exactly what these arguments
expect and what they return:
\begin{description}
\item[blocksize] \mbox{}

{\ttfamily stat()} is is happy to provide callers with a
blocksize value. This blocksize is often not the right one
for use with bmap. The {\ttfamily stat()} man page indicates
that {\ttfamily stat.st\_blksize} is for efficient filesystem I/O.
The blocksize suited for use with bmap is available via 
ioctl: {\ttfamily ioctl(fd,FIGETBSZ,\&block\_size)} when
performed against a file descriptor returns the file
block size in bytes.



\item[index of the block you wish to map] \mbox{}

index is computed in units of blocksize per the
above discussion. index is zero-based.



\item[offset of that block with respect to the underlying block device] \mbox{}

index is computed in units of blocksize per the above
discussion. index is zero-based. {\bfseries NOTE:} This offset
is against the start of the block device on which the
filesystem is mounted. This is usually a partition -- not
the physical device on which the partition sits.
Files with holes usually return 0 as their block offset for
blocks that exist in the hole.

\end{description}





\subsubsection{Device Determination;}

{\ttfamily bmap} and {\ttfamily slacker} contain code that allows them to 
do I/O against the raw block device. Under linux, it takes
a bit of work just to determine {\bfseries where} a file is located.
{\ttfamily stat()} returns the major/minor of the block device via
{\ttfamily stat.st\_dev} -- but this is difficult information to use.

Three ways leap immediately to mind:
\begin{description}
\item[{\ttfamily mknod}] \mbox{}

A new device node could be created somewhere with the
major/minor numbers supplied by {\ttfamily stat()}. A
serious downside is that a writeable volume must
exist on the system in order for the device nodes to
be created.



\item[walk /dev] \mbox{}

This method can be done with an existing filesystem, but
the cost can be high. A /dev tree may feature thousands
of entries on a modern system and the target entry may
be buried hundreds or thousands of entries deep. This
penalty could be extreme if the /dev tree were located
on a remote system -- although this situation should be
extremely rare.



\item[maintain an internal mapping] \mbox{}

This method is an attempt to speed up lookups in /dev
by build-time precomputing a table with major/minor and
node names for many block devices. The target device
is checked to determine that the major/minor numbers
are actually correct as a check.

\end{description}


{\ttfamily bmap} and freinds maintain an internal mapping for fast lookups.
This saves measureable time when bmap is invoked as the object of a file-system
walk over tens of thousands of files. Currently, however, they do not
search or store this mapping very efficiently.




\subsection{Advanced Block Map Techniques}






\subsubsection{Undeleting files (brute force)}

\begin{enumerate}
\item Determine byte offset of string with respect to beginning of block
device containing filesystem
\item Compute sector(s) containing string
\item Generate inode sector lists exhaustively over the filesystem
\begin{verbatim}
find * -exec bmap {} >> /another_file_system/blocks \;
\end{verbatim}
\item Sort lists from step (3) into a single list
\begin{verbatim}
cat /another_file_system/blocks | sort -n | uniq > > /another_file_system/blocks.sorted
\end{verbatim}
\item Identify the contiguous set of unallocated sectors surrounding
the sectors from step (4)
\item Extract the sector set identified in step (5)
\item Done
\end{enumerate}





\subsubsection{Undeleting files (openinode)}

Scyld's {\ttfamily openinode} kernel patch relieves most of the complexity
of 'undeleting' files. However, a simple postprocessing step is often
useful when attempting to validate recovered files -- a check should
be made to determine if file blocks from the recovered file have been
subsequently allocated to other files.

\begin{enumerate}
\item Generate inode sector list for the recovered file
\item Generate inode sector lists exhaustively over the filesystem
\begin{verbatim}
find * -exec bmap {} >> /another_file_system/blocks \;
\end{verbatim}
\item Sort lists from step (3) into a single list
\begin{verbatim}
cat /another_file_system/blocks | sort -n | uniq > > /another_file_system/blocks.sorted
\end{verbatim}
\item See if any of the sectors reported for the recovered file
\item Done      
\end{enumerate}


Unfortunately, lack of collisions is not enough to guarantee that a
recovery is correct. Consider:

\begin{enumerate}
\item User {\ttfamily tom} creates a file F(tom) containg the
details of his baseball card collection. This results in the
creation of an inode I(tom) mapped into the inode
space of the filesystem and a vector of blocks V(tom)
containing file data or metadata.
\item User {\ttfamily tom} deletes F(tom). Presuming that 
no other links to I(tom) exist, the filesystem is now
free to reclaim (seperately) both the inode entry I(tom)
and the blocks listed in V(tom).
\item User {\ttfamily dick} creates a file F(dick) containing
a great new picture of two midgets and a horse from
alt.rec.stepladders.and.livestock. This results in the creation
of an inode I(dick) mapped into the inode space of the
filesystem and a vector of blocks V(dick) containing file
data or metadata. Let us stipulate, for the example,
that V(dick) exactly equals V(tom) -- which is to say
that the picture of midgets now occupies the blocks
previously dedicated to the baseball cards.
\item At this point, V(dick) may contain blocks reclaimed from
V(tom). This does not imply that I(dick) is mapped into the
filesystem on the same inode number as I(tom). We can detect
this block reuse when recovering F(tom) by exhaustively
comparing the elements of V(tom) against the elements of
every other V() associated with every other I()
in the filesystem -- we would learn that V(dick) contains blocks
reclaimed from V(tom). Obviously, we must regard at least portions
of F(tom) as unrecoverable if its blocks have been recycled!
\item User {\ttfamily dick} deletes F(dick). Presuming that 
no other links to I(dick) exist, the filesystem is now
free to reclaim (seperately) both the inode entry I(dick)
and the blocks listed in V(dick).
\item At this point, a simple validation pass
(as per above) would fail to reveal that V(tom) was
reused as V(dick) because F(dick) has been removed.
If we had failed to consider this point (as analysts
surely have) we might have already fired {\ttfamily tom} from his job J(tom) for the midget picture! Perhaps we
could increase the sophistication of the validation
pass to survey every V() associated with every inode 
in the inode space -- we could maybe see that
a file,F(dick), was created after F(tom) and contained blocks
reclaimed from V(tom).
        
\item The waters muddy further when user {\ttfamily harry} creates a
file F(harry) containg his Christmas shopping list. This results
in the creation of an inode I(harry) mapped into the inode
space of the filesystem and a vector of blocks V(harry)
containing file data or metadata. Let us stipulate, for the example,
that I(harry) is mapped onto the same inode number that
I(dick) was mapped onto. 
\item At this point, we are still tempted to believe that
our recovered F(tom) contains a picture of midgets ;
further that {\ttfamily tom} was deliberately hiding his
pictures under a fake name. Unlike previous steps where
a mechanism existed for determining that elements of V(tom)
had been reallocated, every record of F(dick) -- namely I(dick) and
V(dick) -- has been obliterated.
\end{enumerate}


While that situation sounds dire, there may still be hope for {\ttfamily tom} before he's (wrongly) sent off to jail for child pornography. Modern
journalling filesystems may contain extra information that allows us
to exactly determine whether tom's original file is recoverable.




\subsection{Library Interface}

\begin{verbatim}
#include <bmap.h>
\end{verbatim}


\begin{verbatim}
extern int bmap_get_slack_block(
                int fd,
                long *slack_block,
                long *slack_bytes,
                long *block_size);
extern int bmap_get_block_size(int fd);
extern int bmap_get_block_count(
                int fd,
                const struct stat *statval);
extern int bmap_map_block(int fd,unsigned long block);
extern int bmap_raw_open(
                const char *filename,
                mode_t mode);
extern void bmap_raw_close(int fd);
\end{verbatim}





\section{Credits}

I would like to thank the \ifpdf
\href{www.hq.nasa.gov/office/oig/}{NASA Office of Inspector General}%
\else
\onlynameurl{NASA Office of Inspector General}%
\fi{}
 for having the special
needs that caused me to write this utility in the first place.



I would like to thank Bob Hergert of the \ifpdf
\href{www.dcfl.gov}{Defense Computer Forensics Lab}%
\else
\onlynameurl{Defense Computer Forensics Lab}%
\fi{}
 for developing the
{\ttfamily xscale} companion utility and for testing this product.



I would like to thank the FBI SWG-DE (Scientific Working Group on
Digital Evidence) for working to establish and promulgate guidelines
that make it feasable to apply high-performance computing techniques
to the computer forensics process.



\end{document}
