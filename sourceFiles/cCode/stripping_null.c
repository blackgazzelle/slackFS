/*
AUTHOR: Avinash Srinivasan
Code File: strippingNullBytes.c
This program hides a filesystem ".dmg" within the
slack space of files specified with a coverfile list.

The program takes as input the mapFile (.txt) the
null-free .dmg file generated by 'strippingNullBytes.c'
along with a coverfile list(.txt file) that has the
full-path of files that can be used as cover files
along with the available slack space for each potential
coverfile.
*/

// below macro def is necessary for asprintf
// has to appear before #include<stdio.h>
#ifndef _GNU_SOURCE
#define _GNU_SOURCE 1
#endif

#include "slackFS.h"

int main(int argc, char const *argv[])
{
  int ch, bytes2Write=0, size=0, totalBytesWritten=0;
  int nullADD=0, nullLEN=0;

  FILE *fpMap, *fpSRC, *fpDST;

  // root folder of all project files
  // need to update the fixedPATH for your system
  char *fixedPATH = "../../";

  // will store complete path to srcIMG
  char srcFullPATH [128] = {0};

  // will store complete path to dstIMG
  char dstFullPATH [128] = {0};

  // will store complete path to mapFile
  char mapPath [128] = {0};

  // relative paths to srcIMG, dstIMG, and mapFile from fixedPATH
  // file to strip off all NULL bytes from
  char srcIMG[] = "imageFiles/myimg.img";

  // file to create that is a copy of srcIMG without NULL bytes
  char dstIMG[] = "imageFiles/myimg.img";

  // below file will be created with the start address
  // and length of every NULL byte sequence in the srcIMG
  char mapFile[] = "mapFiles/mapFile_myimg.txt";

  // below 6 lines of code can be eliminated if assigning
  // absolute path to srcIMG, dstIMG, and mapFile and update
  // variables accordingly
  strncpy(srcFullPATH, fixedPATH, strlen(fixedPATH));
  strcat(srcFullPATH, srcIMG);
  strncpy(dstFullPATH, fixedPATH, strlen(fixedPATH));
  strcat(dstFullPATH, dstIMG);
  strncpy(mapPath, fixedPATH, strlen(fixedPATH));
  strcat(mapPath, mapFile);

  // file size will be used later when parsing through
  // the srcIMG to remove NULL bytes
  struct stat st;
  stat(srcFullPATH, &st);
  int statFileSize = st.st_size;

  // variables to store start address and length
  // of each null byte sequence in the srcIMG
  char str_nullADD[4], str_nullLEN[4];

  // make an entry of the start address and length
  // of each null byte sequence in secIMG
  fpMap = fopen(mapPath, "w");
  if (fpMap==NULL)
  {
    perror("mapFile");
    ferror(fpMap);
    fclose(fpMap);
    exit(EXIT_FAILURE);
  }

  // open the raw filesystem (.dmg, .dd, etc)
  // in binary to remove null bytes from
  fpSRC = fopen(srcFullPATH, "rb");
  if (fpSRC == NULL)
  {
    perror("srcIMG");
    ferror(fpSRC);
    fclose(fpSRC);
    exit(EXIT_FAILURE);
  }

  // create a new raw filesystem (.dmg, .dd, etc)
  // with no NULL bytes
  fpDST = fopen(dstFullPATH, "wb");
  if (fpDST == NULL)
  {
    perror("dstIMG");
    ferror(fpDST);
    fclose(fpDST);
    exit(EXIT_FAILURE);
  }

  // parse through the filesystem image to remove all NULL bytes
  for (int byteOffset = 0; byteOffset < statFileSize-1; )
  {
    ch = fgetc(fpSRC);

    nullLEN = 0;
    // if 'ch' is null, then compute the length
    if(ch==0x00)
    {
      nullADD = ftell(fpSRC)-1;
      do
      {
        nullLEN++;
        // verifying we are not stepping beyond filesize
        if(ftell(fpSRC)-1 > statFileSize-2)
        {
          // make the final entry to mapFile
          fprintf(fpMap, "%d %d\n", nullADD, nullLEN);
          fclose(fpSRC);
          fclose(fpDST);
          return 0;
        }

        ch = fgetc(fpSRC);

      } //checking the length of the null byte sequence
      while( ch == 0x00);

      // make an entry to mapFile
      fprintf(fpMap, "%d %d\n", nullADD, nullLEN);
      byteOffset = ftell(fpSRC)-1;

      // if the character 'ch' is not NULL, then write it to dstIMG
      fputc(ch, fpDST);
    }

    // if the character 'ch' is not NULL, then write it to dstIMG
    else
    {
      fputc(ch, fpDST);
      byteOffset++;
    }
  }

  fclose(fpMap);
  fclose(fpSRC);
  fclose(fpDST);

  return 0;
}
